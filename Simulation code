#-----------------------------
#---------- READ ME ----------
#-----------------------------

# The following is a Python 3 code for a 3D direct N-body simulation of two colliding clusters.
# The bodys are placed randomly in the borders of each cluster.
# The bodies have radii.
# Once two bodies "touch" each other they won't interact.
#   ^ This simulates them passing by each other, having the gravitational force neutralised.
#   ^ Without it the numerical error caused by reaching high acceleration would be significant, not preserving energy.

# Three procedures are performed:
# 1. Initialising pos. & vel. vectors of all bodies
# 2. Running, creating a time series. Has all positions in all frames.
# 3. Displaying the time series, or saving it.
#    One can display a saved time series.

# NumPy and Matplotlib are required.

# Further explanations are given in the code.

# Written by Alon Granek, 2020.

# ---------------------------------------------


import numpy as np
import matplotlib.pyplot as mplot
import matplotlib.animation as anim
from mpl_toolkits.mplot3d import Axes3D
import random


#-------------------------------
#---------- VARIABLES ----------
#-------------------------------

### Scalar constants ###
N = 2000                    # Body count.
Gm = 7*(10**7)              # Gravitational parameter G*m of each body.
dt = 0.001                  # Timestep.
Diam = 30                   # Body diameter.
LenUnit = 2000              # Length unit. Must be at least the body count (explained further below).

### Related to running ###
dtCount = 1000              # Frame count.
TimeSeries = np.zeros([3,N,dtCount])    # Position time series. [x/y/z, body index, frame index]
AccTimeSeries = np.zeros([N,dtCount])   # Acceleration time series. [x/y/z, body index, frame index]

### State vectors ###
Pos = np.zeros([3,N])       # Position. [x/y/z, body index]
Vel = np.zeros([3,N])       # Velocity. [x/y/z, body index]
Acc = np.zeros([3,N])       # Acceleration. [x/y/z, body index]
AbsAcc = np.zeros(N)        # Acceleration magnitude. [body index]
Vel0 = 10000                # Initial velocity magnitude.


#-------------------------------
#---------- FUNCTIONS ----------
#-------------------------------

#### initialiseStates ####
# Random positions are generated inside two boxes.
# Each box has dimensions [LenUnit,LenUnit,LenUnit/2].
# For simplicity, the random positions are generated by sampling for each dimension.
# Therefore  LenUnit >= N  is required.
# After that, initial velocities are set as [+-Vel0,0,0].
def initialiseStates():
    Pos[0,0:int(N/2)] = random.sample(np.arange(int(0.5*LenUnit),int(2.5*LenUnit)).tolist() , k=int(N/2))
    Pos[0,int(N/2):N] = random.sample(np.arange(int(3.5*LenUnit),int(5.5*LenUnit)).tolist() , k=int(N/2))
    #
    Pos[1,0:int(N/2)] = random.sample(np.arange(int(1.75*LenUnit),int(2.75*LenUnit)).tolist() , k=int(N/2))
    Pos[1,int(N/2):N] = random.sample(np.arange(int(2.25*LenUnit),int(3.25*LenUnit)).tolist() , k=int(N/2))
    #
    Pos[2,0:int(N/2)] = random.sample(np.arange(int(0.5*LenUnit),int(LenUnit)).tolist() , k=int(N/2))
    Pos[2,int(N/2):N] = random.sample(np.arange(int(LenUnit),int(1.5*LenUnit)).tolist() , k=int(N/2))
    #
    Vel[:,0:int(N/2)] = Vel0*np.ones(int(N/2)) , np.zeros(int(N/2)) , np.zeros(int(N/2))
    Vel[:,int(N/2):N] = -Vel0 *np.ones(int(N/2)) , np.zeros(int(N/2)) , np.zeros(int(N/2))


#### Find acceleration of body i, for the current step ####
def findCurrentAcc(i):
    j = list(range(0,i))+list(range(i+1,N-1))   # List of indices of all other bodies.
    Sum_r_Abs_r3 = np.zeros(3)                  # Sum of all r/|r|^3. [x/y/z]
    r = np.subtract(Pos[:,j],Pos[:,i*np.ones(len(j),dtype=int)])    # Position difference vector. [x/y/z, index in list j]
    Abs_r3 = np.linalg.norm(r,axis=0)**3        # |r|^3. [index in list j]
    NonTouching_jIndices = np.where(Abs_r3 >= Diam**3)[0]   # Indices in list j, of bodies that don't touch i (|r| >= Diam).
    Sum_r_Abs_r3 = np.sum(np.divide(r[:,NonTouching_jIndices],0.001*Abs_r3[NonTouching_jIndices]),axis=1)   # Summing all r/|r|^3 of bodies that don't touch i.
    Acc[:,i] = Gm * Sum_r_Abs_r3 * 0.001        # Acceleration of body i, given the r/|r|^3 sum.


#### Find velocity of body i for the next timestep ####
def findNextVel(i):
    Vel[:,i] += Acc[:,i]*dt


#### Find position of body i for the next timestep ####
# This uses the velocity of the CURRENT timestep, found by the previous iteration of findNextVel(i).
def findNextPos(i):
    Pos[:,i] += Vel[:,i]*dt + 0.5*Acc[:,i]*(dt**2)


#### Run simulation, create time series [x/y/z,body,timestep] ####
def Run(dtCount):                   # Done given a frame count.
    print("Initial states set. Starting to run.")
    for t in range(dtCount-1):      # For each timestep.
        for i in range(N-1):        # For each body i.
            findCurrentAcc(i)       # Find current acceleration components.
            findNextPos(i)          # Find next position.
            findNextVel(i)          # Find next velocity components.
        TimeSeries[:,:,t] = Pos[:,:]    # Insert positions [x/y/z,body] for each timestep.
        AccTimeSeries[:,t] = np.linalg.norm(Acc,axis=0)     # Insert acceleration magnitudes [body] for each timestep.
        print(" ",(t+1),"of",dtCount,"frames loaded.",end="\r")     # Display number of loaded frames, real-time.


#### Form a scatter, displaying a frame in the time-series given timestep t.
def Update(t):
    ax.clear()
    ax.grid(False)      # No grid.
    ax.set_xticks([])   # No ticks.
    ax.set_yticks([])
    ax.set_zticks([])
    #
    ax.w_xaxis.line.set_color((1.0, 1.0, 1.0, 0.0))     # No axes.
    ax.w_yaxis.line.set_color((1.0, 1.0, 1.0, 0.0))
    ax.w_zaxis.line.set_color((1.0, 1.0, 1.0, 0.0))
    ax.w_xaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))     # No panes except for the floor.
    ax.w_yaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))
    ax.w_zaxis.set_pane_color((0.05, 0.05, 0.05, 1))
    #
    ax.set_xlim3d(1.5*lenunit,5.5*lenunit)              # Axes limits using LenUnit.
    ax.set_ylim3d(1*lenunit,4*lenunit)
    ax.set_zlim3d(-0.25*lenunit,2.25*lenunit)
    # Display time series scatter. Color points according to acceleration magnitude.
    ax.scatter(TimeSeries[0,1:N-1,t],TimeSeries[1,1:N-1,t],TimeSeries[2,1:N-1,t],s=4,c=AccTimeSeries[1:N-1,t],cmap="plasma")


#### Save created simulation ####
# Parameter "name" holds the name (or adress with name, otherwise appears in user folder)
def saveNewSim(name):
    np.savetxt(name+"X_2Streams.txt",TimeSeries[0,:,:])     # Save time series x values in txt file.
    np.savetxt(name+"Y_2Streams.txt",TimeSeries[1,:,:])     # Save time series y values in txt file.
    np.savetxt(name+"Z_2Streams.txt",TimeSeries[2,:,:])     # Save time series z values in txt file.
    np.savetxt(name+"_Acc_2Streams.txt",AccTimeSeries[:,:])     # Save acceleration time series in txt file.
    np.savetxt(name+"_Props_2Streams.txt",np.array([N,dtCount,LenUnit]))    # Save properties (N,dtCount,LenUnit) in txt file.


#### Load saved time series ####
def loadSavedSim(name):
    n,dtcount,lenunit = np.loadtxt(name+"_Props_2Streams.txt").astype(int)
    TimeSeries = np.zeros([3,n,dtcount])
    TimeSeries[0,:,:] = np.loadtxt(name+"X_2Streams.txt")
    TimeSeries[1,:,:] = np.loadtxt(name+"Y_2Streams.txt")
    TimeSeries[2,:,:] = np.loadtxt(name+"Z_2Streams.txt")
    AccTimeSeries = np.loadtxt(name+"_Acc_2Streams.txt")
    def Update(t):
        ax.clear()
        ax.grid(False)      # No grid.
        ax.set_xticks([])   # No ticks.
        ax.set_yticks([])
        ax.set_zticks([])
        #
        ax.w_xaxis.line.set_color((1.0, 1.0, 1.0, 0.0))     # No axes.
        ax.w_yaxis.line.set_color((1.0, 1.0, 1.0, 0.0))
        ax.w_zaxis.line.set_color((1.0, 1.0, 1.0, 0.0))
        ax.w_xaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))     # No panes except for the floor.
        ax.w_yaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))
        ax.w_zaxis.set_pane_color((0.05, 0.05, 0.05, 1))
        #
        ax.set_xlim3d(1.5*lenunit,5.5*lenunit)              # Axes limits using LenUnit.
        ax.set_ylim3d(1*lenunit,4*lenunit)
        ax.set_zlim3d(-0.25*lenunit,2.25*lenunit)
        # Display time series scatter. Color points according to acceleration magnitude.
        ax.scatter(TimeSeries[0,1:N-1,t],TimeSeries[1,1:N-1,t],TimeSeries[2,1:N-1,t],s=4,c=AccTimeSeries[1:N-1,t],cmap="plasma")
    A = anim.FuncAnimation(fig,Update,interval=40)          # Animate scatters in time interval 40ms (25 fps. Can be any interval. 17 yields ~60 fps).
    mplot.show()


fig = mplot.figure()
mplot.style.use('dark_background')
ax = Axes3D(fig)


#--------------------------
#---------- MAIN ----------
#--------------------------

def Main():
    print("New simulation - '1'")
    print("Load saved simulation - '2'")
    Input = input()
    if (Input == "1"):          # "New simulation" mode.
        initialiseStates()      # Initialise states.
        Run(dtCount)            # Form time series.
        Scatter = ax.scatter(0,0,0)
        A = anim.FuncAnimation(fig,Update,interval=20)  # Animate and show.
        mplot.show()
        print("Save new simulation - '1'")  # After closing the figure window - option to save.
        Input = input()
        if (Input == "1"):              # If choosing option.
            Input = input("Name: ")     # Input name. Save time series by that name.
            saveNewSim(Input)
    if (Input == "2"):          # "Load saved" option.
        name = input("Name: ")  # Name.
        loadSavedSim(name)      # Load saved time series.

Main()
